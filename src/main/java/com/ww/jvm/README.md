## 类加载

![v2-b9d39568c0e3f87a5df6a0cbfe753cda_r](img\v2-b9d39568c0e3f87a5df6a0cbfe753cda_r.jpg)

加载.class文件大致可以分为3个步骤：

* 1、检查是否已经加载，有就直接返回，避免重复加载；
* 2、当前缓存中确实没有该类，那么遵循双亲委派机制，加载.class文件；
* 3、上面两步都失败了，调用findClass()方法加载；

```java
Class类的构造器是私有的，无法手动new一个Class对象，只能由JVM创建，JVM在构造Class对象时，需要传入一个类加载器（类加载器中的defineClass方法自动构造的），然后完成上述一连串的加载、创建过程。   
    
    在运行期间，一个类，只有一个Class对象产生。
```



* 问题：调用method.invoke(obj, args)，为什么要传入一个目标对象？

  方法是共用的，JVM如何保证p1调用changeUser()时，changeUser()不会跑去把p2的数据改掉？

  所以JVM设置了一种隐性机制，每次对象调用方法时，都会**隐性传递**当前调用该方法的**对象参数**，方法可以根据这个对象参数知道当前调用本方法的是哪个对象。

### 类加载过程详解

![20210805145958](img\20210805145958.png)

Java虚拟机规范指出，必须调用初始化场景：

* 1、使用new关键字实例化对象的时候；
* 2、读取或设置一个类型的静态字段的时候；
* 3、调用一个类型的静态方法的时候；
* 4、使用java.lang.reflect包的方法对类型进行反射调用的时候；
* 5、当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
* 6、当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类；
* 7、当一个接口定义了JDK8新加入的默认方法（被default修改）时，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。
  * 区别：当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。

#### 加载

需要完成以下三件事：

* 1、通过类名找到class文件，获取字节数组；
* 2、将字节数组转化为方法区的运行时数据结构；
* 3、在堆内存中构建一个Class对象，作为方法区这个类的各种数据访问的入口。

#### 连接

##### 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束。

* 1、文件格式验证
  * 是否以魔数cafe babe开头；
  * 主、次版本号是否在当前Java虚拟机接收范围之内；
  * 。。。
* 2、元数据验证
  * 这个类是否有父类；
  * 这个类的父类是否继承了不允许被继承的类；
  * 如果不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；
  * 。。。
* 3、字节码验证
  * 保证任何跳转指令都不会跳转到方法体以外的字节码指令上；
  * 。。。
* 4、符号引用验证
  * 符号引用中通过字符串描述的全限定名是否能找到对应的类；
  * 。。。

##### 准备

准备阶段是正式为类中定义的静态变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但是必须注意到方法区本身是一个逻辑上的区域，JDK7及之前，HotSpot使用永久代来实现该方法区，在**JDK8及之后，类变量则会随着Class对象一起存放在Java堆中**。

```java
注意：
    1、这里说的仅包括类变量，不包括实例变量；
    2、这里所说的初始值“通常情况”下是数据类型的零值；
    例如：
    public static int value = 123;
	变量value在准备阶段过后的初始值为0而不是123，因为这个时候尚未开始执行任何Java方法。把value赋值为123的动作要到类的初始化阶段才会被执行。
```

##### 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

#### 初始化

直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。

初始化阶段就是执行类构造器<clinit>()方法的过程。

<clinit>()方法由编译器自动收集类中的所有类变量的赋值动作和静态代码块合并产生的。

<clinit>()方法与类的构造方法不同，不需要显示地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。

```java
Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地枷锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程阻塞。
```

