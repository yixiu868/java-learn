# 集合

## List

### ArrayList

默认大小10

每次扩容原来1.5倍

### 线程安全List

#### Vector

底层结构数组

线程安全

每次扩容2倍

#### CopyOnWriteArrayList

参考链接

[CopyOnWriteArrayList详解](https://www.cnblogs.com/ding-dang/p/13152223.html)

juc包下

##### add()方法说明

首先会加lock，锁住后会复制出一个新的数组，往新数组里边add真正的元素，最后把array的指向改为新的数组。

##### 缺点

* ①很显然，很耗内存，每次set()/add()都会复制一个数组出来。

* ②只能保证最终一致性，不能保证实时一致性，例如线程A去读取数据，还没读完，此时线程B把这个List清空了，线程A还是可以把剩余的数据读出来。

  ![image](img\image.png)

##### 适用场景

CopyOnWrite并发容器是用于读多写少的并发场景。比如黑名单、白名单等。

## Map

常见实现类`HashMap`、`LinkedHashMap`、`TreeMap`、`ConcurrentHashMap`

### HasMap

底层结构：数组+链表/红黑树

默认值：初始大小16，负载因子0.75

`要求`：HashMap大小只能是2次幂，比如传10进去实际大小为16，传7进去实际大小为8

#### 1.7、1.8区别

1.7链表采用头插法，在扩容时可能出现`环型链表`，造成死循环；

1.8采用尾插法，可以避免出现次问题。

#### 为什么HashMap大小只能为2次幂

因为只有为2次幂时，才能用位运算替代取模。

#### 负载因子

比如HashMap默认大小16，负载因子0.75，意味着最多只能存12个元素，一旦超过12个元素，哈希表就需要扩容。

#### put方法实现

put的时候，首先对key做hash运算，计算出key所在的index。

如果哈希表满了，则需要进行扩容；

如果没有碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况进行插入。

#### get方法实现

get时候，对key做hash运算，计算出key所在的index，然后判断是否有hash冲突，如果有冲突，判断是链表还是红黑树。

#### 如何判断值相同的

首先会比较hash值，然后会用==运算符和equals()判断该元素是否相同。

说白了，就是如果只有hash值相同那么说明该元素hash冲突了，如果hash和equals或者==也都相同，说明该元素是同一个。

#### 什么情况下才会用到红黑树

当`数组`的大小`大于64`且`链表`的大小`大于8`会将链表改为红黑树，当红黑树`大小为6`时，会退化为链表。

`链表查询时间复杂度O(N),插入时间复杂度O(1)，红黑树查询和插入时间复杂度O(logN)`

#### 重新equals，一定要重写hashCode

如果对equals方法进行了重写，一定要对hashCode方法进行重写，以保证相同的对象返回相同的hash值，不同对象返回不同hash值。

### LinkedHashMap

底层结构：数组+链表+双向链表

实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。有了这个双向链表，我们的插入可以是有序的，这里的有序不是值大小有序，而是插入有序。

### TreeMap

底层结构：红黑树

TreeMap的key不能为null（如果为null，还怎么排序），TreeMap有序是通过Comparator来进行比较的

### ConcurrentHashMap

底层结构：数组+链表/红黑树

支持高并发的访问和更新，是线程安全的，还有HastTable也是线程安全，性能不行。

##### 原理

通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile来修饰。

在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程所负责的区间加锁。